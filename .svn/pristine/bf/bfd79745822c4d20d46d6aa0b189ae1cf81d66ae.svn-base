/**
 * 
 */
package com.android.smartmobile.cz.util;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.xmlpull.v1.XmlPullParserException;

import android.content.Context;
import android.graphics.Color;
import android.os.Handler;
import android.os.Message;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.android.smartmobile.cz.R;
import com.android.smartmobile.cz.bean.AddressBean;
import com.android.smartmobile.cz.bean.MapItem;
import com.android.smartmobile.cz.finals.Constants;
import com.android.smartmobile.cz.map.OfflineCacheTiledServiceLayer;
import com.android.smartmobile.cz.model.MyApplication;
import com.android.smartmobile.cz.service.PullParseConfigMapService;
import com.android.smartmobile.cz.view.MainMapView;
import com.android.smartmobile.cz.view.pop.PopGestureManager;
import com.esri.android.map.Callout;
import com.esri.android.map.CalloutStyle;
import com.esri.android.map.GraphicsLayer;
import com.esri.android.map.GroupLayer;
import com.esri.android.map.Layer;
import com.esri.android.map.MapView;
import com.esri.android.map.TiledLayer;
import com.esri.android.map.ags.ArcGISDynamicMapServiceLayer;
import com.esri.android.map.ags.ArcGISFeatureLayer;
import com.esri.android.map.ags.ArcGISLocalTiledLayer;
import com.esri.android.map.ags.ArcGISTiledMapServiceLayer;
import com.esri.core.geometry.Envelope;
import com.esri.core.geometry.Geometry;
import com.esri.core.geometry.Point;
import com.esri.core.geometry.Polygon;
import com.esri.core.geometry.Polyline;
import com.esri.core.map.Graphic;
import com.esri.core.symbol.FillSymbol;
import com.esri.core.symbol.PictureMarkerSymbol;
import com.esri.core.symbol.SimpleFillSymbol;
import com.esri.core.symbol.SimpleLineSymbol;
import com.esri.core.symbol.SimpleMarkerSymbol;

/**
 * 
 * @ClassName: MapHelper
 * @Description: 地图辅助类
 * @author Administrator
 * @date 2013年8月5日 上午11:24:53
 * @Company: www.shdci.com
 * @Copyright: Copyright (c) 2013 All rights reserved.
 * @version
 */
public class MapHelper {
	private static GraphicsLayer highlightgraphicsLayer = null;
	private static final int FLASH_SHOW = 0x0001, FLASH_HIDE = 0x0002;
	private static SimpleMarkerSymbol symbol_point = null;
	private static SimpleFillSymbol symbol_polygon = null;
	private static SimpleLineSymbol symbol_line = null;
	private static boolean flashing = false;
	private static Thread flashThread = null;

	/**
	 * 
	 */
	private MapHelper() {
		// TODO Auto-generated constructor stub

	}

	// 离线切片
	private List<ArcGISLocalTiledLayer> mapLayer_local = null; // 切片图层
	// 在线切片
	private List<ArcGISTiledMapServiceLayer> mapLayer_online = null; // 切片图层

	/**
	 * 返回当前显示切片的层数
	 * 
	 * @return
	 */
	public int getCurrentLevel() {
		if (mapLayer_local != null && mapLayer_local.size() > 0) {
			return mapLayer_local.get(0).getCurrentLevel();
		}
		if (mapLayer_online != null && mapLayer_online.size() > 0) {
			return mapLayer_online.get(0).getCurrentLevel();
		}
		return 0;
	}

	public static void AddTiledMapLayer(MapView mapView, String layerName) {
		String file = Constants.TPKCachePath + "/+" + layerName + ".tpk";
		if (new File(file).exists()) {
			MapHelper.AddLocalMapLayer(mapView, layerName);
			ToastUtil.makeToastInBottom("tpk模式：" + file);
		} else {
			try {
				com.android.smartmobile.cz.bean.Layer layer1 = PullParseConfigMapService
						.getLayerByName(layerName);

				layer1.setResolution(MyApplication.mApp.appConfigInfo
						.getResolution());
				layer1.setScale(MyApplication.mApp.appConfigInfo.getScale());
				com.esri.android.map.GroupLayer groupLayer = new com.esri.android.map.GroupLayer();
				groupLayer.setName(layerName);
				groupLayer.addLayer(new OfflineCacheTiledServiceLayer(
						Constants.MapCachePath, layer1));
				mapView.addLayer(groupLayer, 0); // 添加地图服务到map中

			} catch (XmlPullParserException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			ToastUtil.makeToastInBottom("在线模式：" + layerName);
		}

	}

	/**
	 * 加载地图
	 * 
	 * @param mapView
	 */
	public static void AddBaseMapLayer(MapView mapView, int index) {
		try {
			MapItem item = PullParseConfigMapService.getMapsgement().get(index);
			if (!StringUtil.isEmpty(item.getType())
					&& item.getType().equalsIgnoreCase("WMS")) {
				AddDynamicMapServiceLayer(mapView, item.getUrl(),
						item.getName());
			} else if (!StringUtil.isEmpty(item.getType())
					&& item.getType().equalsIgnoreCase("WMTS")) {
				AddTiledMapLayer(mapView, item.getName());
			} else if (!StringUtil.isEmpty(item.getType())
					&& item.getType().equalsIgnoreCase("TPK")) {
				AddLocalMapLayer(mapView, item.getName());

			}

		} catch (XmlPullParserException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void AddLocalMapLayer(MapView mapView, String layerName) {

		// 加载离线缓存切片
		String path = "file:///" + Constants.TPKCachePath + "/" + layerName
				+ ".tpk";
		LogUtil.LoLoLog().d(path);
		ArcGISLocalTiledLayer layer1 = new ArcGISLocalTiledLayer(path);
		layer1.setName(layerName);
		mapView.addLayer(layer1); // 添加地图服务到map中

	}

	public static void AddFeatureLayer(MapView mapView, String layerPath,
			String layerName) {

		ArcGISFeatureLayer featureLayer = new ArcGISFeatureLayer(layerPath,
				ArcGISFeatureLayer.MODE.ONDEMAND);
		featureLayer.setName(layerName);
		mapView.addLayer(featureLayer); // 添加地图服务到map中
	}

	public static void AddDynamicMapServiceLayer(MapView mapView,
			String layerPath, String layerName) {

		ArcGISDynamicMapServiceLayer dynamicMapServiceLayer = new ArcGISDynamicMapServiceLayer(
				layerPath);
		dynamicMapServiceLayer.setName(layerName);
		mapView.addLayer(dynamicMapServiceLayer); // 添加地图服务到map中
	}

	public static Layer getLayerByName(MapView mapView, String layerName) {
		Layer[] layers = mapView.getLayers();
		for (Layer l : layers) {
			if (layerName.equals(l.getName())) {
				return l;
			}

			if (l instanceof ArcGISLocalTiledLayer) {
				if (layerName.equals(l.getName())) {
					return l;
				}
			}
		}
		return null;
	}

	/**
	 * 高亮显示
	 * 
	 * @param geometries
	 *            要闪烁的对象
	 * @param zoomToIt
	 *            是否要ZoomTo对象范围
	 */
	public static void flashGeometrys(MapView mapView,
			List<Geometry> geometries, GraphicsLayer hGraphicsLayer,
			boolean zoomToIt) {
		highlightgraphicsLayer = hGraphicsLayer;
		// 初始化高亮显示

		// 初始化Symbols
		symbol_point = new SimpleMarkerSymbol(Color.BLUE, 18,
				SimpleMarkerSymbol.STYLE.CIRCLE);
		symbol_line = new SimpleLineSymbol(Color.BLUE, 5.0f);

		symbol_polygon = new SimpleFillSymbol(Color.GREEN);
		// symbol_polygon.setOutline(new SimpleLineSymbol(Color.RED, 5.0f));
		// symbol_polygon.setAlpha(3);

		if (geometries == null || geometries.size() == 0)
			return;
		Graphic graphic = null;
		Envelope envelope = new Envelope();
		for (Geometry g : geometries) {
			if (g.getType() == Geometry.Type.POINT) {
				Point p = ((Point) g);
				envelope.merge(p);
				graphic = new Graphic(g, symbol_point);
			}
			if (g.getType() == Geometry.Type.POLYLINE) {
				Polyline p = ((Polyline) g);
				envelope.merge(getPolyLineExtent(p));
				graphic = new Graphic(g, symbol_line);
			}
			if (g.getType() == Geometry.Type.POLYGON) {
				Polygon p = ((Polygon) g);
				envelope.merge(getPolygonExtent(p));
				graphic = new Graphic(g, symbol_polygon);
			}
			if (graphic != null)
				// highlightgraphicsLayer.removeAll();
				highlightgraphicsLayer.addGraphic(graphic);
		}
		if (zoomToIt){
			setExtent(mapView, envelope);
		}
			
		// mapView.setScale(13000);
		// Message message = new Message();
		// message.what = 0;
		// myHandler.sendMessage(message);

		// _mapc.getMap().setScale(2000.0);
		flashing = false;
		try {
			Thread.sleep(501);
			flashing = true;
			flashThread = new Thread(drawing);
			flashThread.start();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	static Runnable drawing = new Runnable() {
		public void run() {
			int i = 0;
			while (flashing) {
				if (i == 100)
					i = 0;
				i++;
				Message message = new Message();
				message.what = (i % 2 == 0 ? FLASH_SHOW : FLASH_HIDE);
				myHandler.sendMessage(message);
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {
				}
			}
		}
	};

	static Handler myHandler = new Handler() {
		public void handleMessage(Message msg) {
			switch (msg.what) {

			case FLASH_HIDE:
				highlightgraphicsLayer.setVisible(false);
				break;
			case FLASH_SHOW:
				highlightgraphicsLayer.setVisible(true);

				break;

			}
			super.handleMessage(msg);
		}
	};

	/**
	 * 设置显示范围
	 * 
	 * @param geometry
	 */
	public void setExtent(MapView mapView, Geometry geometry) {
		mapView.setExtent(geometry, 10);
	}

	/**
	 * 设置显示范围
	 * 
	 * @param envelope
	 */
	public static void setExtent(MapView mapView, Envelope envelope) {
		mapView.setExtent(envelope);
		mapView.setScale(50000.0);
	}

	public static Envelope getPolyLineExtent(Polyline line) {
		if (line == null)
			return null;
		double min_x = line.getPoint(0).getX(), min_y = line.getPoint(0).getY(), max_x = line
				.getPoint(0).getX(), max_y = line.getPoint(0).getY();
		int count = line.getPointCount();
		for (int i = 0; i < count; i++) {
			double tmp_x = line.getPoint(i).getX();
			double tmp_y = line.getPoint(i).getY();
			if (tmp_x > max_x)
				max_x = tmp_x;
			if (tmp_x < min_x)
				min_x = tmp_x;
			if (tmp_y > max_y)
				max_y = tmp_y;
			if (tmp_y < min_y)
				min_y = tmp_y;
		}
		return new Envelope(min_x, min_y, max_x, max_y);
	}

	public static Envelope getPolygonExtent(Polygon gon) {
		if (gon == null)
			return null;
		double min_x = gon.getPoint(0).getX(), min_y = gon.getPoint(0).getY(), max_x = gon
				.getPoint(0).getX(), max_y = gon.getPoint(0).getY();
		int count = gon.getPointCount();
		for (int i = 0; i < count; i++) {
			double tmp_x = gon.getPoint(i).getX();
			double tmp_y = gon.getPoint(i).getY();
			if (tmp_x > max_x)
				max_x = tmp_x;
			if (tmp_x < min_x)
				min_x = tmp_x;
			if (tmp_y > max_y)
				max_y = tmp_y;
			if (tmp_y < min_y)
				min_y = tmp_y;
		}
		Envelope envelope = new Envelope(min_x, min_y, max_x, max_y);

		return envelope;
	}

	/**
	 * 清空绘制内容
	 */
	public void clearFlashGeometrys() {
		flashing = false;
		highlightgraphicsLayer.removeAll();
	}

	public static void showCalloutView(final MapView mapView,
			final Context context, final AddressBean addressBean, Point cent) {
		// String centerPoint = addressBean.getCentroid();
		// String string = centerPoint.replaceFirst("POINT", "")
		// .replaceAll("\\(", "").replaceAll("\\)", "");
		// String[] pointStringArray = string.split(" ");
		// Point mapPoint = new Point(
		// StringUtil.String2Double(pointStringArray[0]),
		// StringUtil.String2Double(pointStringArray[1]));

		final Callout callout = mapView.getCallout();

		// callout.setOffset(0, 10);
		CalloutStyle style = new CalloutStyle();
		style.setAnchor(5);
		style.setBackgroundColor(Color.parseColor("#FFFFFF"));
		// style.setBackgroundAlpha(10);
		style.setCornerCurve(1);
		// style.setFrameColor(R.color.tra);
		callout.setStyle(style);
		View view1 = LayoutInflater.from(context).inflate(
				R.layout.layout_callout, null);
		callout.setContent(view1);
		// Button btn_callout_modify = (Button) view1
		// .findViewById(R.id.btn_callout_modify);

		TextView txt = (TextView) view1.findViewById(R.id.txt_callout);
		Button btn_callout_go = (Button) view1
				.findViewById(R.id.btn_callout_go);

		txt.setText(addressBean.getName());
		if (!callout.isShowing()) {
			// mapView.setOnStatusChangedListener(onStatusChangedListener);
			mapView.zoomToScale(cent, 20000);
			callout.setCoordinates(cent);
			callout.show();
		} else {
			mapView.zoomToScale(cent, 20000);
			callout.move(cent);
		}

		btn_callout_go.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				callout.hide();
				PopGestureManager popGestureManager = new PopGestureManager(
						context, mapView);
				if (null != popGestureManager.getPopupWindow()) {
					popGestureManager.getPopupWindow().dismiss();
					popGestureManager.setPopupWindow(null);
					return;
				} else {
					popGestureManager.init(addressBean);
					int[] location = new int[2];

					Constants.ll_right_menu.getLocationOnScreen(location);

					popGestureManager.getPopupWindow().showAtLocation(
							Constants.ll_right_menu,
							Gravity.NO_GRAVITY,
							location[0]
									- popGestureManager.getPopupWindow()
											.getWidth() + 70, location[1]);

				}
			}

		});
	}

	public static double getScale(double scale) {
		if (scale > 0 && scale <= 500) {
			return 500;
		} else if (scale > 500 && scale <= 1000) {
			return 1000;
		} else if (scale > 1000 && scale <= 2000) {
			return 2000;
		} else if (scale > 2000 && scale <= 5000) {
			return 5000;
		} else if (scale > 5000 && scale <= 10000) {
			return 10000;
		} else if (scale > 10000 && scale <= 20000) {
			return 20000;
		} else if (scale > 20000 && scale <= 50000) {
			return 50000;
		} else if (scale > 50000 && scale <= 100000) {
			return 100000;
		} else if (scale > 100000 && scale <= 200000) {
			return 200000;
		} else if (scale > 200000 && scale <= 500000) {
			return 500000;
		} else if (scale > 500000 && scale <= 1000000) {
			return 1000000;
		} else if (scale > 1000000 && scale <= 2000000) {
			return 2000000;
		} else if (scale > 2000000 && scale <= 5000000) {
			return 5000000;
		} else if (scale > 0 && scale <= 10000000) {
			return 10000000;
		}
		return 500;

	}

	public static String getScaleString(double scale) {
		if (scale > 0 && scale <= 500) {
			return "5 米";
		} else if (scale > 500 && scale <= 1000) {
			return "10 米";
		} else if (scale > 1000 && scale <= 2000) {
			return "20 米";
		} else if (scale > 2000 && scale <= 5000) {
			return "50 米";
		} else if (scale > 5000 && scale <= 10000) {
			return "100 米";
		} else if (scale > 10000 && scale <= 20000) {
			return "200 米";
		} else if (scale > 20000 && scale <= 50000) {
			return "500 米";
		} else if (scale > 50000 && scale <= 100000) {
			return "1 公里";
		} else if (scale > 100000 && scale <= 200000) {
			return "2 公里";
		} else if (scale > 200000 && scale <= 500000) {
			return "5 公里";
		} else if (scale > 500000 && scale <= 1000000) {
			return "10 公里";
		} else if (scale > 1000000 && scale <= 2000000) {
			return "20 公里";
		} else if (scale > 2000000 && scale <= 5000000) {
			return "50 公里";
		} else if (scale > 0 && scale <= 10000000) {
			return "100 公里";
		}
		return "5 米";

	}

	// ----------------------绘制圆形-----------------------
	private static GraphicsLayer drawCircleLayer = null;

	/**
	 * 绘制圆,配合 clearDrawCircleLayer()清除
	 * 
	 * @param center
	 * @param radius
	 * @param alpha
	 * @param FillColor
	 */
	public static void DrawCircle(MapView mapView, Point center, double radius,
			int alpha, int FillColor) {
		if (drawCircleLayer == null) {
			drawCircleLayer = new GraphicsLayer();
			mapView.addLayer(drawCircleLayer);
		} else {
			drawCircleLayer.removeAll();
		}
		Polygon polygon = new Polygon();
		getCircle(center, radius, polygon);
		FillSymbol symbol = new SimpleFillSymbol(FillColor);
		symbol.setAlpha(alpha);

		Graphic g = new Graphic(polygon, symbol);
		drawCircleLayer.addGraphic(g);
	}

	/**
	 * 获取圆的图形对象
	 * 
	 * @param center
	 * @param radius
	 * @return
	 */
	public static Polygon getCircle(Point center, double radius) {
		Polygon polygon = new Polygon();
		getCircle(center, radius, polygon);
		return polygon;
	}

	private static void getCircle(Point center, double radius, Polygon circle) {
		circle.setEmpty();
		Point[] points = getPoints(center, radius);
		circle.startPath(points[0]);
		for (int i = 1; i < points.length; i++)
			circle.lineTo(points[i]);
	}

	private static Point[] getPoints(Point center, double radius) {
		Point[] points = new Point[50];
		double sin;
		double cos;
		double x;
		double y;
		for (double i = 0; i < 50; i++) {
			sin = Math.sin(Math.PI * 2 * i / 50);
			cos = Math.cos(Math.PI * 2 * i / 50);
			x = center.getX() + radius * sin;
			y = center.getY() + radius * cos;
			points[(int) i] = new Point(x, y);
		}
		return points;
	}

	/**
	 * 通过中心点坐标和半径得到正方形的四个点
	 * 
	 * @param x
	 * @param y
	 * @param r
	 * @return
	 */
	public static List<Point> getRectangleFromPR(double x, double y, double r) {
		List<Point> list = new ArrayList<Point>();
		list.add(new Point(x - r, y - r));// 左下角点
		list.add(new Point(x + r, y - r));// 右下角点
		list.add(new Point(x + r, y + r));// 右上角点
		list.add(new Point(x - r, y + r));// 左上角点
		list.add(new Point(x - r, y - r));// 左下角点(封闭点)
		return list;
	}

	public static String getPolygonGeometry(double x, double y, double r) {
		List<Point> points = getRectangleFromPR(x, y, r);
		String result = null;
		if (points.size() > 0) {
			for (int i = 0; i < points.size(); i++) {
				Point p1 = points.get(i);
				if (i == 0) {
					result = String.valueOf(p1.getX()) + " "
							+ String.valueOf(p1.getY());
				} else {
					result = result + "," + String.valueOf(p1.getX()) + " "
							+ String.valueOf(p1.getY());
				}

			}
			result = "POLYGON((" + result + "))";
			result = "ST_GeometryFromText('" + result + "', 2437)";
		}
		return result;
	}
}
